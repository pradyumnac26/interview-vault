{"version":3,"sources":["../../../src/runtime/server/clerkMiddleware.ts"],"sourcesContent":["import type { AuthenticateRequestOptions } from '@clerk/backend/internal';\nimport { AuthStatus, constants, getAuthObjectForAcceptedToken } from '@clerk/backend/internal';\nimport { deprecated } from '@clerk/shared/deprecated';\nimport { handleNetlifyCacheInDevInstance } from '@clerk/shared/netlifyCacheHandler';\nimport type { PendingSessionOptions } from '@clerk/types';\nimport type { EventHandler } from 'h3';\nimport { createError, eventHandler, setResponseHeader } from 'h3';\n\nimport { clerkClient } from './clerkClient';\nimport type { AuthFn, AuthOptions } from './types';\nimport { createInitialState, toWebRequest } from './utils';\n\nfunction parseHandlerAndOptions(args: unknown[]) {\n  return [\n    typeof args[0] === 'function' ? args[0] : undefined,\n    (args.length === 2 ? args[1] : typeof args[0] === 'function' ? {} : args[0]) || {},\n  ] as [EventHandler | undefined, AuthenticateRequestOptions];\n}\n\ninterface ClerkMiddleware {\n  /**\n   * @example\n   * export default clerkMiddleware((event) => { ... }, options);\n   */\n  (handler: EventHandler, options?: AuthenticateRequestOptions): ReturnType<typeof eventHandler>;\n\n  /**\n   * @example\n   * export default clerkMiddleware(options);\n   */\n  (options?: AuthenticateRequestOptions): ReturnType<typeof eventHandler>;\n}\n\n/**\n * Middleware for Nuxt that handles authentication and authorization with Clerk.\n *\n * @example\n * Basic usage with options:\n * ```ts\n * export default clerkMiddleware({\n *   authorizedParties: ['https://example.com']\n * })\n * ```\n *\n * @example\n * With custom handler:\n * ```ts\n * export default clerkMiddleware((event) => {\n *   // Access auth data from the event context\n *   const { auth } = event.context\n *\n *   // Example: Require authentication for all API routes\n *   if (!auth.userId && event.path.startsWith('/api')) {\n *     throw createError({\n *       statusCode: 401,\n *       message: 'Unauthorized'\n *     })\n *   }\n * })\n * ```\n *\n * @example\n * With custom handler and options:\n * ```ts\n * export default clerkMiddleware((event) => {\n *   // Access auth data from the event context\n *   const { auth } = event.context\n *\n *   // Example: Require authentication for all API routes\n *   if (!auth.userId && event.path.startsWith('/api')) {\n *     throw createError({\n *       statusCode: 401,\n *       message: 'Unauthorized'\n *     })\n *   }\n * }, {\n *   authorizedParties: ['https://example.com']\n * })\n * ```\n */\nexport const clerkMiddleware: ClerkMiddleware = (...args: unknown[]) => {\n  const [handler, options] = parseHandlerAndOptions(args);\n  return eventHandler(async event => {\n    const clerkRequest = toWebRequest(event);\n\n    const requestState = await clerkClient(event).authenticateRequest(clerkRequest, {\n      ...options,\n      acceptsToken: 'any',\n    });\n\n    const locationHeader = requestState.headers.get(constants.Headers.Location);\n    if (locationHeader) {\n      handleNetlifyCacheInDevInstance({\n        locationHeader,\n        requestStateHeaders: requestState.headers,\n        publishableKey: requestState.publishableKey,\n      });\n      // Trigger a handshake redirect\n      return new Response(null, { status: 307, headers: requestState.headers });\n    }\n\n    if (requestState.status === AuthStatus.Handshake) {\n      throw createError('Clerk: handshake status without redirect');\n    }\n\n    if (requestState.headers) {\n      requestState.headers.forEach((value, key) => {\n        setResponseHeader(event, key, value);\n      });\n    }\n\n    const authObjectFn = (opts?: PendingSessionOptions) => requestState.toAuth(opts);\n    const authHandler: AuthFn = ((options?: AuthOptions) => {\n      return getAuthObjectForAcceptedToken({ authObject: authObjectFn(options), acceptsToken: options?.acceptsToken });\n    }) as AuthFn;\n\n    const auth = new Proxy(authHandler, {\n      get(target, prop, receiver) {\n        deprecated('event.context.auth', 'Use `event.context.auth()` as a function instead.');\n        // If the property exists on the function, return it\n        if (prop in target) {\n          return Reflect.get(target, prop, receiver);\n        }\n        // Otherwise, get it from the authObject\n        return authObjectFn()?.[prop as keyof typeof authObjectFn];\n      },\n    });\n\n    event.context.auth = auth;\n    // Internal serializable state that will be passed to the client\n    event.context.__clerk_initial_state = createInitialState(authObjectFn());\n\n    await handler?.(event);\n  });\n};\n"],"mappings":"AACA,SAAS,YAAY,WAAW,qCAAqC;AACrE,SAAS,kBAAkB;AAC3B,SAAS,uCAAuC;AAGhD,SAAS,aAAa,cAAc,yBAAyB;AAE7D,SAAS,mBAAmB;AAE5B,SAAS,oBAAoB,oBAAoB;AAEjD,SAAS,uBAAuB,MAAiB;AAC/C,SAAO;AAAA,IACL,OAAO,KAAK,CAAC,MAAM,aAAa,KAAK,CAAC,IAAI;AAAA,KACzC,KAAK,WAAW,IAAI,KAAK,CAAC,IAAI,OAAO,KAAK,CAAC,MAAM,aAAa,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC;AAAA,EACnF;AACF;AA+DO,MAAM,kBAAmC,IAAI,SAAoB;AACtE,QAAM,CAAC,SAAS,OAAO,IAAI,uBAAuB,IAAI;AACtD,SAAO,aAAa,OAAM,UAAS;AACjC,UAAM,eAAe,aAAa,KAAK;AAEvC,UAAM,eAAe,MAAM,YAAY,KAAK,EAAE,oBAAoB,cAAc;AAAA,MAC9E,GAAG;AAAA,MACH,cAAc;AAAA,IAChB,CAAC;AAED,UAAM,iBAAiB,aAAa,QAAQ,IAAI,UAAU,QAAQ,QAAQ;AAC1E,QAAI,gBAAgB;AAClB,sCAAgC;AAAA,QAC9B;AAAA,QACA,qBAAqB,aAAa;AAAA,QAClC,gBAAgB,aAAa;AAAA,MAC/B,CAAC;AAED,aAAO,IAAI,SAAS,MAAM,EAAE,QAAQ,KAAK,SAAS,aAAa,QAAQ,CAAC;AAAA,IAC1E;AAEA,QAAI,aAAa,WAAW,WAAW,WAAW;AAChD,YAAM,YAAY,0CAA0C;AAAA,IAC9D;AAEA,QAAI,aAAa,SAAS;AACxB,mBAAa,QAAQ,QAAQ,CAAC,OAAO,QAAQ;AAC3C,0BAAkB,OAAO,KAAK,KAAK;AAAA,MACrC,CAAC;AAAA,IACH;AAEA,UAAM,eAAe,CAAC,SAAiC,aAAa,OAAO,IAAI;AAC/E,UAAM,eAAuB,CAACA,aAA0B;AACtD,aAAO,8BAA8B,EAAE,YAAY,aAAaA,QAAO,GAAG,cAAcA,UAAS,aAAa,CAAC;AAAA,IACjH;AAEA,UAAM,OAAO,IAAI,MAAM,aAAa;AAAA,MAClC,IAAI,QAAQ,MAAM,UAAU;AAC1B,mBAAW,sBAAsB,mDAAmD;AAEpF,YAAI,QAAQ,QAAQ;AAClB,iBAAO,QAAQ,IAAI,QAAQ,MAAM,QAAQ;AAAA,QAC3C;AAEA,eAAO,aAAa,IAAI,IAAiC;AAAA,MAC3D;AAAA,IACF,CAAC;AAED,UAAM,QAAQ,OAAO;AAErB,UAAM,QAAQ,wBAAwB,mBAAmB,aAAa,CAAC;AAEvE,UAAM,UAAU,KAAK;AAAA,EACvB,CAAC;AACH;","names":["options"]}